・Application[chat]
svcとenvを包括する概念
最初にapplicationの命名を行うこと

・Environment[test,production]
各environmentにはデプロイされたすべてのresource軍を含む
Network(VPC,subnet,security groupなど), ECSクラスタ、ELB、
同一envでServiceをデプロイするとそのサービスは同一のECSクラスタと同一networkで利用できる
copilot initするとtest Environmentを作成するか尋ねられる
ネットワークを作成するための必要なリソース(vpc , subnet, security groupなど)と複数のServiceでの共有を目的としたApplication LoadBalancerやECSクラスタを含んでいる
サービスをEnvironmentにデプロイすることでこれらのネットワークリソースを使用する
---- SSL/TLS ------
所有するドメイン名を Route 53 に登録するよう、Application 作成時にオプションとして設定できます。ドメイン名の利用が設定されている場合、Copilot は各 Environment の作成時に environment-name.app-name.your-domain.com のような形でサブドメインを登録し、ACM を通して発行した証明書を Application Load Balancer に設定します。これにより Service が HTTPS を利用できるようになります。

RDS等を使う場合は,environmentを作成した際に自動生成されるEnvironmentSecurityGroupをinbound ruleに追加


・Service [frontend ,api]
最初にtypeを定義[Application Load Balancer]
Dockerfileからコンテナimageを作成、ECRリポジトリへ収納
Serviceの設定情報に基づきmanifestファイルを作成
最初のcopilot initでapplication名とservice名を尋ねられる(manifest.ymlと空のECRリポジトリが生成される)
２回目のcopilot initで追加する２個目のservice名のみを尋ねられる
publicサブネットのみで実行され、ロードバランサーを経由したトラフィックのみを受け取る

Load Balanced Web ServiceタイプでServiceが作成されると、同一Environment内にデプロイされたすべえての"Load Balanced Web Service"のServiceは、Service固有のリスナーを作成してこのLoadBalancerを共有する。
ロードバランサーはVPC内の各Serviceと通信できるようにセットアップされる

copilot init コマンド実行時に作成されるmanifest.ymlはService用の共通設定やoptionを含んでいる

copilot svc deployコマンド
→Dockerfileからimageをlocalにbuild
→gitコミットのhash値でDockerイメージにtag付け
→DockerイメージをECRにpush
→manifest.ymlをもとにCloudFormationテンプレートを作成
→ECSタスクの作成、更新

